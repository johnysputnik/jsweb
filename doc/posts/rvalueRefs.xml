<?xml version="1.0"?>
<blog xmlns:wp="http://wordpress.org/export/1.2/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
<post>
    <title>lvalue &amp; rvalue &amp; &amp;&amp; and &amp;&amp; &amp; </title>
    <date>2013-01-26 10:01:54</date>
    <tag1>C++ 11</tag1>
    <tag2/>
    <tag3/>
    <tag4/>    
<summary>
      lvalues and rvalues and lvalue reference types and rvalue
      reference types are a fairly reliable path to insanity..... or are
      they? This post is an attempt to cement a few things in my 
      mind as well as explain to those who are interested what on 
      earth is going on with lvalues, rvalues and references. 
    </summary>
    <contents><![CDATA[

lvalues and rvalues and lvalue reference types and rvalue reference types are a fairly reliable path to insanity..... or are they?

This post is an attempt to cement a few things in my mind as well as explain to those who are interested what on earth is going on with lvalues, rvalues and references. If after reading this you are none the wiser then I strongly advise you go and check out <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">Scott Meyers talk on Universal References on Channel 9</a>. He can explain it a lot better than I can.
<h2>lvalue vs rvalue</h2>
Ok, so first a what is an lvalue and what is an rvalue? My understanding is this:

An lvalue is an assigned value and an rvalue is a non assigned value. In this example x is an lvalue and 10 is an rvalue:
<pre class="prettyprint lang-cpp">int x = 10;</pre>
Also, in this case the result of a + b is an rvalue:
<pre class="prettyprint lang-cpp">int x = a + b;</pre>
"So what?", I hear you ask. Well it turns out that move semantics make use of this terminology to provide a type that can be readily identified as one that can be moved rather than copied. An rvalue is by it's nature transient and it is this transience that provides the hint that perhaps we can use this feature to assist in move semantics.
<h2>Move Semantics</h2>
The best example to explain why move semantics are so important is a large collection of objects such as a vector or some other list. If we are passing vectors around by value, every time we assign an instance, we call the copy constructor on that vector and each element is allocated and assigned in the new vector. Sometimes, we are not interested in the state of the original vector and the overhead could prove unacceptable. It would be much more efficient to move the allocated memory from one vector to the other and performance would be improved significantly.

We could do this ourselves, but C++ 11 now has a <a href="http://en.wikipedia.org/wiki/C%2B%2B11#Rvalue_references_and_move_constructors">feature</a>, rvalue references, that allows us to identify situations where we could do this.

The reason it is called Move Semantics, as I understand it, is because the moving described above can be done without rvalue references. Rvalue references are just a means to allow differentiation and therefore overloading, in order to provide both copy and move constructors, assignment operators and other methods.

So how about some examples.
<h2>An Example using Move Semantics</h2>
So lets put together a quick example class:
<pre class="prettyprint lang-cpp">class Example
{
public:
    Example(const Example&amp; other)
    {
        mList = other.mList;
    }

    Example(Example&amp;&amp; other)
    {
        mList = std::move(other);
    }

private:
    std::vector&lt;std::string&gt; mList;   
};</pre>
The two constructors include a standard copy constructor and a move constructor using an RVALUE REFERENCE TYPE - <em>Example&amp;&amp;</em>. Note that the '&amp;&amp;' is an individual token on its own rather than two &amp; tokens as far as the compiler is concerned. We also use std::move to convert other to an rvalue as due to it being an assigned variable is an lvalue of TYPE = RVALUE REFERENCE TO AN Example OBJECT. This is important to get your head round.

There is also nothing stopping you write std::move in the copy constructor but semantically that would not make sense in a COPY constructor. A MOVE constructor is made possible by the new rvalue reference type, permitting overloading and allowing move SEMANTICS.

So if you are using named variables that are ALWAYS lvalues how do we get an rvalue. As I mentioned earlier an rvalue is a transient value. The call to std::move RETURNS AN RVALUE REFERENCE TO AN RVALUE. Infact, std::move is the standard way to convert an lvalue to an rvalue and hints at the possibility that <em>other</em> may change as it can now be moved.

So, to summarise, moving can obviously be done without rvalue reference types, but rvalue reference types provide a distinction that allows for standardised move semantics that are used throughout the standard library and can be used to optimise parts of code where copying would naturally take place.
<h2>Further Insanity Inducing Rvalue References</h2>
Hopefully, some of what I have said makes some form of sense and it is clear at least that there is a new reference construct that can help provide a standard way of optimisation via move semantics. Now we are going to throw templates and, more generally, type deduction into the mix. Type deduction happens in templates, with the auto keyword and in a few other places in C++. I'm going to just look at templates, hopefully it will indicate how the other features are affected by this.

Lets create a couple of template functions:
<pre class="prettyprint lang-cpp">template&lt;T&gt;
void doSomething(const std::vector&lt;T&gt;&amp; withThis);

template&lt;T&gt;
void doSomething(std::vector&lt;T&gt;&amp;&amp; withThis);</pre>
We now have two overloaded function that can take advantage of scenarios that might require optimisation.

We can call these as follows:
<pre class="prettyprint lang-cpp">std::vector&lt;std::string&gt; v;

doSomething(v);
doSomething(std::move(v));</pre>
The first call uses the first template function  and the second call, as it is getting an rvalue via std::move, is calling the second template function. Quite simple really - the std::move call tells the reader of the code that <em>doSomething</em> will probably also 'do something' to v and we should probably not expect to use v beyond the call to doSomething.

Now what if I had written the following template functions instead:
<pre class="prettyprint lang-cpp">template&lt;T&gt;
void doSomething(const T&amp; withThis);

template&lt;T&gt;
void doSomething(T&amp;&amp; withThis);</pre>
It will probably surprise you that in the code above where doSomething is called, they will BOTH call the second template function.

If I was to call the function as follows, the first override would be called:
<pre class="prettyprint lang-cpp">const std::vector&lt;std::string&gt; v;

doSomething(v);</pre>
"Eh?" I hear you ask.

The important thing here is TYPE DEDUCTION.  the first example of the doSomething functions, the type is a std::vector&lt;T&gt;&amp; the T is deduced, BUT the std::vector is not.

In our new example of the doSomething functions, we do have a deduced type T. Deduced types can be const, non const, rvalue references, lvalue references, in fact anything. So in our new cases, the compiler INTERNALLY, created the following instantiated function calls from the template:
<pre class="prettyprint lang-cpp">void doSomething(std::vector&lt;std::string&gt;&amp; &amp;&amp; withThis);
void doSomething(std::vector&lt;std::string&gt;&amp;&amp; &amp;&amp; withThis);</pre>
These statements are illegal in written code, but internally that is how the compiler sorts out type deduction. So, you may ask, "What the hell is the type once it makes its way to the function body???". This is obviously an important question as the semantics of the type used to call the function are blurred if not careful.

Well it turns out that the references collapse, following to the following rules:
<pre class="prettyprint lang-cpp">T&amp; &amp; -&gt; T&amp;
T&amp;&amp; &amp; -&gt; T&amp;
T&amp; &amp;&amp; -&gt; T&amp;
T&amp;&amp; &amp;&amp; -&gt; T&amp;&amp;</pre>
Still sane?

So what we are effectively telling the compiler to instantiate in the way of function calls is:
<pre class="prettyprint lang-cpp">void doSomething(std::vector&lt;std::string&gt;&amp;  withThis);
void doSomething(std::vector&lt;std::string&gt;&amp;&amp; withThis);</pre>
This means that the body of the template function could be recieving an lvalue reference or an rvalue reference type, so we have to accept that semantically, it should not assume that the caller expects move semantics to come into play. So if we actually moved <em>withThis</em>, using std::move for example, the state of the application might not be what the caller expected it to be after the call to doSomething.

Fortunately, the standard library comes to our aid with std::forward to allow forwarding of the object to a non deduced function. I think I will leave it there for now, perhaps come back to std::forward some other time. There is quite a good explanation in <a href="http://stackoverflow.com/questions/8526598/how-does-stdforward-work">this thread</a>, of how std::forward works.

&nbsp;
<h4>If you are still none the wiser, <a href="http://channel9.msdn.com/Shows/Going+Deep/Cpp-and-Beyond-2012-Scott-Meyers-Universal-References-in-Cpp11">watch what Scott Meyers has to say about it</a>, he's a bit more of an expert than me :)</h4>]]></contents>

  </post>

</blog>
